DROP TABLE IF EXISTS "card_has_tag";
DROP TABLE IF EXISTS "card";
DROP TABLE IF EXISTS "list";
DROP TABLE IF EXISTS "tag";

-- Création de notre table list.
-- Je ne rajoute pas le IF NOT EXISTS car juste au dessus je DROP déjà la table si elle existe.
CREATE TABLE "list" (
    -- INTEGER => Précise que l'id sera obligatoire un nombre entier (1, 2, 3, ..., 89, etc...)
    -- GENERATED ALWAYS AS IDENTITY => L'id sera généré automatiquement par la BDD, on n'a pas le droit de le renseigner nous même.
    -- GENERATED BY DEFAULT AS IDENTITY => Si on utilse BY DEFAULT, l'id sera généré seulement si on ne le renseigne pas nous même.
    -- SERIAL => C'est un équivalent de GENERATED ALWAYS AS IDENTITY, mais ce mot clé est spécifique à PostgreSQL, contrairement à GENERATED ALWAYS AS IDENTITY qui est valable pour tout type de BDD (Postgres, MySQL, etc...) (cette méthode a été déprécié par Postgres).
    -- PRIMARY KEY => Spécifie que l'id sera la clé primaire.
    "id" INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    -- TEXT => Précise que ce sera une varialbe de type STRING (une chaine de caractères), sans limite de caractère (Spécifique à Postgres).
    -- VARCHAR => Précise que ce sera une varialbe de type STRING (une chaine de caractères), avec une limite de caractère (par défaut si on ne précise pas le nombre de caractère, la limite sera fixée à 255).
    -- NOT NULL => On ne pourra pas créer de liste sans nom.
    "name" VARCHAR NOT NULL,
    "position" INTEGER NOT NULL,
    -- TIMESTAMPTZ => (TIMESTAMP WITH TIME ZONE), précise un type DATE.
    -- DEFAULT => Permet de renseigner une valeur par défaut si elle n'est pas déjà renseignée dans la requête d'ajout d'une liste.
    "created_at" TIMESTAMPTZ DEFAULT NOW(),
    "updated_at" TIMESTAMPTZ
);

CREATE TABLE "card" (
    "id" INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    "name" VARCHAR NOT NULL,
    "position" INTEGER NOT NULL,
    "color" VARCHAR,
    "created_at" TIMESTAMPTZ DEFAULT NOW(),
    "updated_at" TIMESTAMPTZ,
    -- Clé étrangère => C'est une clé primaire d'une autre table.
    -- REFERENCES [nom_de_la_table]("id") => Permet de créer une relation au sein de la BDD entre la propriété list_id et la propriété id (de la table list).
    -- ON DELETE CASCADE => Cette option permettrait de supprimer toutes les card en rapport avec les list, à la suppression d'une liste. Pour le moment, je ne rajoute pas cette option car on a pas encore décidé si on voulait pouvoir supprimer une liste alors qu'il y a encore des cartes à l'intérieur.
    -- ex: Si j'ai une card avec un list_id = 1, et que je supprime la list avec l'id = 1, alors la card sera aussi supprimé automatiquement.
    "list_id" INTEGER NOT NULL REFERENCES list("id") -- ON DELETE CASCADE
);

CREATE TABLE "tag" (
    "id" INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    "name" VARCHAR NOT NULL,
    "color" VARCHAR,
    "created_at" TIMESTAMPTZ DEFAULT NOW(),
    "updated_at" TIMESTAMPTZ
);

-- Dans une base de données, on ne peut pas avoir de type tableau (ARRAY)
CREATE TABLE "card_has_tag" (
    "card_id" INTEGER NOT NULL REFERENCES card("id") ON DELETE CASCADE,
    "tag_id" INTEGER NOT NULL REFERENCES tag("id") ON DELETE CASCADE,
    "created_at" TIMESTAMPTZ DEFAULT NOW()
);

-- On a créé notre BDD, on passe au SEEDING:
INSERT INTO "list" ("name", "position") VALUES ('Liste 1', 1);

INSERT INTO "card" ("name", "position", "list_id") VALUES ('Carte 1', 1, 1), ('Carte 2', 1, 1);

INSERT INTO "tag" ("name") VALUES ('Tag 1');

INSERT INTO "card_has_tag" ("card_id", "tag_id") VALUES (1, 1);